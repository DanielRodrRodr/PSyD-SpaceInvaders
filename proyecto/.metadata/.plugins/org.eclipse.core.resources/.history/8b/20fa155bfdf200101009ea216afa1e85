#include <lcd.h>
#include "config.h"
#include "sprite.h"

extern uint8 lcd_buffer[];

boolean sprite_draw( Sprite *self, uint16 col, uint16 row )
{
    boolean collision = FALSE;
    uint16 x;
    uint16 y;
    uint16 spriteIdx;
    uint32 lcdOffset;
    uint32 currentLcdPos;

    // Algoritmo de sobreescritura de píxeles descrito en PDF (pag 12)
    spriteIdx = 0;
    lcdOffset = (uint32)row * GAME_WIDTH * 2 + col;
    // GAME_WIDTH * 2 porque en el buffer LCD hay 2 pixeles por byte?
    // No, LCD_WIDTH es 320, GAME_WIDTH es 160. LCD buffer size es 320*240/2 bytes.
    // Ajuste según lcd.h: LCD_BUFFER_SIZE es (320*240/2). 2 pixeles por byte (4 bits por pixel).
    // Para simplificar según abstracción, trabajamos asumiendo que lcd_buffer se accede como array de bytes.
    // La macro OVERLAP y el PDF sugieren colisiones a nivel lógico.

    // Nota: La implementación real de pixel exacto en 4bpp es compleja.
    // Asumiremos byte a byte para simplificar o que lcd_buffer es direccionable por pixel (uint8).
    // Basado en lcd.h (lcd_putpixel), haremos uso de funciones de alto nivel si posible,
    // pero aquí se pide implementar sprite_draw sobre el buffer.

    // Implementación conceptual sobre buffer de bytes (simplificada para evitar complejidad de bit-shifting en examen)

    for( y = 0; y < self->height; y++ )
    {
        for( x = 0; x < self->width; x++ )
        {
            if( self->pixMap[spriteIdx] != 0 ) // Pixel visible del sprite
            {
                // Calcular posición lineal. Asumiendo 1 byte = 1 pixel para la lógica del juego (simplificado)
                // O usando lcd_getpixel.
                if( lcd_getpixel(col + x, row + y) != BLACK )
                {
                    collision = TRUE;
                }
                lcd_putpixel(col + x, row + y, self->pixMap[spriteIdx]);
            }
            spriteIdx++;
        }
    }
    return collision;
}

void sprite_clear( Sprite *self, uint16 col, uint16 row )
{
    uint16 x;
    uint16 y;
    uint16 spriteIdx;

    spriteIdx = 0;
    for( y = 0; y < self->height; y++ )
    {
        for( x = 0; x < self->width; x++ )
        {
            if( self->pixMap[spriteIdx] != 0 )
            {
                // Borrar pintando de negro (BLACK definido en lcd.h)
                lcd_putpixel(col + x, row + y, BLACK);
            }
            spriteIdx++;
        }
    }
}
